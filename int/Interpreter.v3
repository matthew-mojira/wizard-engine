export "fast:const0" def const0() -> int { return 0; }
export "fast:const1" def const1() -> int { return 1; }
export "fast:constN" def constN(n: int) -> int { return n; }
export "fast:add"    def add(l: int, r: int) -> int { return l + r; }
export "fast:sub"    def sub(l: int, r: int) -> int { return l - r; }
export "fast:seq"    def seq(f: int, s: int) -> int { return s; }
export "fast:select" def select(c: int, t: int, f: int) -> int { return if(c != 0, t, f); }
export "fast:nop"    def nop() -> void {}

def HANDLER_CONST0 = CiWasmTarget.functionId(const0);
def HANDLER_CONST1 = CiWasmTarget.functionId(const1);
def HANDLER_CONSTN = CiWasmTarget.functionId(constN);
def HANDLER_ADD    = CiWasmTarget.functionId(add);
def HANDLER_SUB    = CiWasmTarget.functionId(sub);
def HANDLER_SEQ    = CiWasmTarget.functionId(seq);
def HANDLER_SELECT = CiWasmTarget.functionId(select);
def HANDLER_NOP    = CiWasmTarget.functionId(nop);

export "main" def main() -> int {
	//def prog = Select(Sub(ConstN(1), Const1), Add(Const1, ConstN(100)), Seq(Sub(Add(Const1, ConstN(2)), Const0), ConstN(15)));
	def prog = AST.If(Const1, ConstN(2), ConstN(3));

	//def prog = Const1;
	def bytecode = compile(prog);
	def val = eval(bytecode);

	def f: Func.F = wasmCompile(bytecode);
	def val_ = f.f();

	def buf = StringBuilder.new();
	prog.display(buf);
	buf.ln();
	buf.put1("=> %d", val);
	buf.ln();
	buf.put1("=> %d", val_);
	buf.ln();
	System.puts(buf.extract());

	call();
	return 0;
}

def CALL_FUNC = CiWasmTarget.functionId(call);

def call() {
	System.puts(Strings.format1("call=%d\n", CALL_FUNC));
}

def eval(bytecode: Array<byte>) -> int {
	def vstk = ArrayStack<byte>.new();
	var pc = 0;
	while (pc < bytecode.length) {
		def instruction = Ref<Instruction>.at(bytecode, pc);
		def opcode  = instruction.opcode;
		def operand = instruction.operand;
		pc += Instruction.size;

		match (opcode) {
			CONST0 => vstk.push(0);
			CONST1 => vstk.push(1);
			CONSTN => vstk.push(operand);
			ADD => {
				def right = vstk.pop();
				def left  = vstk.pop();
				vstk.push(left + right);
			}
			SUB => {
				def right = vstk.pop();
				def left  = vstk.pop();
				vstk.push(left - right);
			}
			SEQ => {
				def snd = vstk.pop();
				def fst = vstk.pop();
				vstk.push(snd);
			}
			SELECT => {
				def snd = vstk.pop();
				def fst = vstk.pop();
				def cond = vstk.pop();
				vstk.push(if(cond != 0, fst, snd));
			}
			IF => {
				def cond = vstk.pop();
				if (cond != 0) pc += operand;
			}
			ELSE => {
				pc += operand;
			}
			END => {} // nop
		}
	}
	return vstk.peek();
}

enum Opcode(handler: int) {
	CONST0	(HANDLER_CONST0) 
	CONST1	(HANDLER_CONST1) 
	CONSTN	(HANDLER_CONSTN) 
	ADD	(HANDLER_ADD) 
	SUB	(HANDLER_SUB)
	SEQ     (HANDLER_SEQ)
	SELECT  (HANDLER_SELECT)
	IF      (HANDLER_NOP)
	ELSE    (HANDLER_NOP)
	END     (HANDLER_NOP)
}

layout Instruction {
	+0	opcode:  Opcode;
	+1	operand: byte;
	=2;
}

type AST {
	case Const0 {
		def compile(w: DataWriter) {
			w.putb(Opcode.CONST0.tag).putb(0);
		}
		def display(s: StringBuilder) {
			s.putc('0');
		}
	}
	case Const1 {
		def compile(w: DataWriter) {
			w.putb(Opcode.CONST1.tag).putb(0);
		}
		def display(s: StringBuilder) {
			s.putc('1');
		}
	}
	case ConstN(n: byte) {
		def compile(w: DataWriter) {
			w.putb(Opcode.CONSTN.tag).putb(n);
		}
		def display(s: StringBuilder) {
			s.putd(n);
		}
	}
	case Add(left: AST, right: AST) {
		def compile(w: DataWriter) {
			left.compile(w);
			right.compile(w);
			w.putb(Opcode.ADD.tag).putb(0);
		}
		def display(s: StringBuilder) {
			s.putc('(');
			left.display(s);
			s.puts(" + ");
			right.display(s);
			s.putc(')');
		}
	}
	case Sub(left: AST, right: AST) {
		def compile(w: DataWriter) {
			left.compile(w);
			right.compile(w);
			w.putb(Opcode.SUB.tag).putb(0);
		}
		def display(s: StringBuilder) {
			s.putc('(');
			left.display(s);
			s.puts(" - ");
			right.display(s);
			s.putc(')');
		}
	}
	case Seq(fst: AST, snd: AST) {
		def compile(w: DataWriter) {
			fst.compile(w);
			snd.compile(w);
			w.putb(Opcode.SEQ.tag).putb(0);
		}
		def display(s: StringBuilder) {
			s.putc('(');
			fst.display(s);
			s.puts(" ; ");
			snd.display(s);
			s.putc(')');
		}
	}
	// eager evaluation of branches
	case Select(cond: AST, left: AST, right: AST) {
		def compile(w: DataWriter) {
			cond.compile(w);
			left.compile(w);
			right.compile(w);
			w.putb(Opcode.SELECT.tag).putb(0);
		}
		def display(s: StringBuilder) {
			s.puts("(select ");
			cond.display(s);
			s.putc(' ');
			left.display(s);
			s.putc(' ');
			right.display(s);
			s.putc(')');
		}
	}
	// lazy evaluation of branches
	case If(cond: AST, left: AST, right: AST) {
		def compile(w: DataWriter) {
			cond.compile(w);
			w.putb(Opcode.IF.tag);
			def hole1 = w.pos;
			left.compile(w);
			w.data[hole1] = byte.!(w.pos - hole1 + 1);
			w.putb(Opcode.ELSE.tag);
			def hole2 = w.pos;
			right.compile(w);
			w.data[hole2] = byte.!(w.pos - hole2 + 1);
			w.putb(Opcode.END.tag).putb(0);

		}
		def display(s: StringBuilder) {
			s.puts("(if ");
			cond.display(s);
			s.putc(' ');
			left.display(s);
			s.putc(' ');
			right.display(s);
			s.putc(')');
		}
	}

	def compile(w: DataWriter);
	def display(s: StringBuilder);
}

def Const0 = AST.Const0;
def Const1 = AST.Const1;
def ConstN = AST.ConstN;
def Add = AST.Add;
def Sub = AST.Sub;
def Seq = AST.Seq;
def Select = AST.Select;
def If = AST.If;

def compile(prog: AST) -> Array<byte> {
	def w = DataWriter.new();

	prog.compile(w);
	
	return w.extract();
}

type Func {
	case F(f: () -> int);
}

def wasmCompile(bytecode: Array<byte>) -> Func.F {
	def w = DataWriter.new();

	w.put_uleb32(0); // 0 locals

	var pc = 0;
	while (pc < bytecode.length) {
		def instruction = Ref<Instruction>.at(bytecode, pc);
		def opcode  = instruction.opcode;
		def operand = instruction.operand;
		pc += Instruction.size;

		// setup for handler, if necessary (guest-level operands)
		match (opcode) {
			CONSTN => {
				w.putb(I32_CONST);
				w.put_sleb32(operand);
			}
			_ => ;
		}
		// call handler function
		w.putb(CALL);
		w.put_uleb32(u32.!(opcode.handler));
	}
	w.putb(END);

	// create wasm function
	def sig  = CiWasmTarget.functionTypeId<int, int>();
	def wasm = w.extract();
	def fid  = wave.new_func(sig, Pointer.atContents(wasm), wasm.length);
	if (fid < 0) {
		System.puts("failed to compile wasm function\n");
		System.error("error", "failed to compile");
	}
	def func = CiRuntime.forgeClosure<void, void, int>(Pointer.NULL + fid, void);

	return Func.F(func);
}

def END: byte = 0x0B;
def CALL: byte = 0x10;
def DROP: byte = 0x1A;
def I32_CONST: byte = 0x41;
