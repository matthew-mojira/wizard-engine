enum Opcode {
	CONST,
	UNOP,
	BINOP
}

enum Unop(operand: byte) {
	NEGATE(0x00)
}

enum Binop(operand: byte) {
	ADD(0x00),
	SUB(0x01)
}

layout Instruction {
	+0  opcode: Opcode;
	+1  operand: u8;
	=2;
}

def CONST  = Opcode.CONST.tag;
def UNOP   = Opcode.UNOP.tag;
def BINOP  = Opcode.BINOP.tag;

def NEGATE = Unop.NEGATE.operand;
def ADD    = Binop.ADD.operand;
def SUB    = Binop.SUB.operand;

def PROGRAM_1: Array<byte> = [
	CONST, 1,
	CONST, 2,
	BINOP, ADD
];

def main(args: Array<string>) -> int {
	return interp(PROGRAM_1);
}

def interp(bytecode: Array<byte>) -> int {
	var pc  = 0;
	var sp  = 0;
	def stk = Array<int>.new(128);

 	while (pc < bytecode.length) {
 		def instr = Ref<Instruction>.at(bytecode, pc);
 		def opcode  = instr.opcode;
 		def operand = instr.operand;
 		pc += 2;
 
 		match (opcode) {
 			CONST => {
 				stk[sp++] = operand;
 			}
 			UNOP => {
 				def arg = stk[--sp];
 				var fn: int -> int;
 				match (operand) {
 					Unop.NEGATE.operand => fn = fun(x) => -x;
 				}
 				stk[sp++] = fn(arg);
 			}
 			BINOP => {
 				def arg1 = stk[--sp];
 				def arg0 = stk[--sp];
 				var fn: (int, int) -> int;
 				match (operand) {
 					Binop.ADD.operand => fn = int.+;
 					Binop.SUB.operand => fn = int.-;
 				}
 				stk[sp++] = fn(arg0, arg1);
 			}
 		}
 	}
 
 	return stk[sp - 1];
}
